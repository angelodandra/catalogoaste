import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import PDFDocument from "pdfkit";
import fs from "node:fs/promises";
import path from "node:path";

export const runtime = "nodejs";

function safeStr(v: any) {
  return (v ?? "").toString();
}

function nowIT() {
  return new Date().toLocaleString("it-IT");
}

function publicImageUrl(path: string) {
  const base = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
  return `${base}/storage/v1/object/public/catalog-images/${path}`;
}

async function fetchImageBuffer(url: string): Promise<Buffer | null> {
  try {
    const r = await fetch(url);
    if (!r.ok) return null;
    const ab = await r.arrayBuffer();
    return Buffer.from(ab);
  } catch {
    return null;
  }
}

async function loadLogoBuffer(): Promise<Buffer | null> {
  const candidates = ["logo.jpg", "logo.jpeg", "logo.png"];
  for (const f of candidates) {
    try {
      const full = path.join(process.cwd(), "public", f);
      const buf = await fs.readFile(full);
      if (buf && buf.length) return buf;
    } catch {}
  }
  return null;
}

async function pdfToBuffer(build: (doc: PDFKit.PDFDocument) => Promise<void>) {
  const doc = new PDFDocument({ size: "A4", margin: 28 });
  const chunks: Buffer[] = [];
  doc.on("data", (c) => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
  const done = new Promise<Buffer>((resolve, reject) => {
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);
  });

  await build(doc);
  doc.end();
  return done;
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const catalogId = safeStr(url.searchParams.get("catalogId")).trim();
    if (!catalogId) return new NextResponse("catalogId mancante", { status: 400 });

    const supabase = supabaseServer();

    const { data: prods, error: pErr } = await supabase
      .from("products")
      .select("id, catalog_id, box_number, progressive_number, image_path, is_sold, price_eur")
      .eq("catalog_id", catalogId)
      .order("progressive_number", { ascending: true });

    if (pErr) throw pErr;

    const products = (prods || []) as any[];

    const logoBuf = await loadLogoBuffer();

    const pdf = await pdfToBuffer(async (doc) => {
      const pageW = doc.page.width;
      const pageH = doc.page.height;

      const cols = 3;
      const rows = 3;
      const gap = 10;

      const topHeader = 86;
      const bottomFooter = 22;

      const gridW = pageW - doc.page.margins.left - doc.page.margins.right;
      const gridH = pageH - doc.page.margins.top - doc.page.margins.bottom - topHeader - bottomFooter;

      const cellW = (gridW - gap * (cols - 1)) / cols;
      const cellH = (gridH - gap * (rows - 1)) / rows;

      const startX = doc.page.margins.left;
      const startY = doc.page.margins.top + topHeader;

      const drawHeader = () => {
        const topY = doc.page.margins.top;

        // Logo centrato (se presente in /public/logo.jpg|png)
        if (logoBuf) {
          const maxW = 190;
          const maxH = 48;
          const xLogo = (pageW - maxW) / 2;
          doc.image(logoBuf, xLogo, topY - 6, { fit: [maxW, maxH], align: "center"});
        } else {
          // fallback testo se il logo non c'è
          doc.fontSize(18).font("Helvetica-Bold").text("F.lli D'Andrassi", startX, topY);
        }

        // info sotto (pulite, piccole)
        const infoY = topY + 44;
        doc.fontSize(10).font("Helvetica").text(`Catalogo: ${catalogId}`, startX, infoY);
        doc.fontSize(10).font("Helvetica").text(`Stampa: ${nowIT()}`, startX, infoY + 14);
      };

      const drawFooter = (pageNo: number) => {
        doc.fontSize(9).fillColor("gray").text(`Pagina ${pageNo}`, startX, pageH - doc.page.margins.bottom - 14);
        doc.fillColor("black");
      };

      let pageNo = 1;
      drawHeader();
      drawFooter(pageNo);

      for (let i = 0; i < products.length; i++) {
        const idxOnPage = i % (cols * rows);
        if (i > 0 && idxOnPage === 0) {
          doc.addPage();
          pageNo++;
          drawHeader();
          drawFooter(pageNo);
        }

        const r = Math.floor(idxOnPage / cols);
        const c = idxOnPage % cols;

        const x = startX + c * (cellW + gap);
        const y = startY + r * (cellH + gap);

        doc.roundedRect(x, y, cellW, cellH, 8).strokeColor("#cccccc").lineWidth(1).stroke();

        const p = products[i];
        const box = safeStr(p.box_number || "?");

        const pad = 8;
        const imgX = x + pad;
        const imgY = y + pad;
        const imgW = cellW - pad * 2;
        const imgH = cellH - pad * 2 - 18;

        const path = safeStr(p.image_path).trim();
        if (path) {
          const img = await fetchImageBuffer(publicImageUrl(path));
          if (img) {
            try {
              doc.image(img, imgX, imgY, { fit: [imgW, imgH], align: "center", valign: "center" });
            } catch {
              doc.fontSize(9).fillColor("gray").text("Immagine non disponibile", imgX, imgY + imgH / 2);
              doc.fillColor("black");
            }
          } else {
            doc.fontSize(9).fillColor("gray").text("Immagine non disponibile", imgX, imgY + imgH / 2);
            doc.fillColor("black");
          }
        } else {
          doc.fontSize(9).fillColor("gray").text("Immagine mancante", imgX, imgY + imgH / 2);
          doc.fillColor("black");
        }

        doc.fontSize(12).font("Helvetica-Bold").text(`Cassa ${box} — ${p.price_eur !== null && p.price_eur !== undefined ? `€ ${Number(p.price_eur).toFixed(2)}` : "—"}`, x + pad, y + cellH - 18, { width: cellW - pad * 2 });
        doc.font("Helvetica");
      }
    });

    return new NextResponse(pdf as any, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `inline; filename="catalogo-${catalogId}.pdf"`,
      },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Errore server" }, { status: 500 });
  }
}
